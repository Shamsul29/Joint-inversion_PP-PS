#!/usr/bin/env python3
import os
import re
import numpy as np
import segyio
from pathlib import Path

# ================== USER CONFIG ==================

# Parent folder that contains: inversion_files/ and Vp/ Vs/ Rho/ ...
BASE = Path("/ddnB/work/shamsul/for_prestack_3D_inversion_25Dec_merged")

# Property folders (siblings of inversion_files)
PROP_DIRS = {
    "Vp":  BASE / "Vp",
    "Vs":  BASE / "Vs",
    "Rho": BASE / "Rho",
    # add if you want:
    #"Ip":  BASE / "Ip",
    #"Is":  BASE / "Is",
}

# Output SEG-Y filenames (written into BASE by default)
OUT_FILES = {
    "Vp":  BASE / "3D_Vp_from_separated_folder_with_coords_12-28-25_calibration_for_Bakken.sgy",
    "Vs":  BASE / "3D_Vs_from_separated_folder_with_coords_12-28-25_calibration_for_Bakken.sgy",
    "Rho": BASE / "3D_Rho_from_separated_folder_with_coords_12-28-25_calibration_for_Bakken.sgy",
    #"Ip": BASE / "3D_Ip_from_separated_folder_with_coords_12-25-25.sgy",
    #"Is": BASE / "3D_Is_from_separated_folder_with_coords_12-25-25.sgy",
}

# Geometry
first_inline      = 127
first_crossline   = 369
sampling_interval = int(0.002 * 1e6)  # 2 ms in microseconds
target_rows       = 360

# Spatial grid (UTM)
x_spacing = 55
y_spacing = 55
origin_x  = 1441426 + (369 - 240) * x_spacing  # for crossline 369
origin_y  = 652491  + (127 - 4)   * y_spacing  # for inline 127

# ================== HELPERS ==================

def xl_number_from_name(name: str) -> int:
    m = re.search(r"XL(\d+)", name)
    if not m:
        raise ValueError(f"Could not parse XL number from: {name}")
    return int(m.group(1))

def discover_prop_files(prop_dir: Path, prop: str) -> tuple[list[int], dict[int, Path]]:
    """
    Find crossline CSVs in a property folder.
    Accepts:
      - XL###_<prop>.csv
      - XL###.csv (fallback)
    Returns sorted crosslines list and mapping xl->path.
    """
    if not prop_dir.is_dir():
        raise RuntimeError(f"Missing folder: {prop_dir}")

    # Prefer XL369_Vp.csv etc
    files = sorted(prop_dir.glob(f"XL*_{prop}.csv"))
    if not files:
        files = sorted(prop_dir.glob("XL*.csv"))

    if not files:
        raise RuntimeError(f"No XL*.csv files found in {prop_dir}")

    xl_to_path = {}
    for f in files:
        xl = xl_number_from_name(f.name)
        xl_to_path[xl] = f

    xls = sorted(xl_to_path.keys())
    return xls, xl_to_path

def create_segy_text_header(num_traces: int, prop_name: str, il_min: int, il_max: int, xl_min: int, xl_max: int) -> list[str]:
    line1 = f"C 1 CLIENT: SEG-Y FILE GENERATED BY SEG-YIO ({prop_name})"[:80]
    line5 = f"C 5 NUMBER OF TRACES: {num_traces:<36}"[:80]
    lines = [
        line1.ljust(80),
        "C 2 PROGRAM: Python (segyio library)                    "[:80],
        "C 3 SEG-Y FORMAT SPECIFICATION: SEG-Y REV 1             "[:80],
        "C 4 SAMPLING INTERVAL: 0.002 SECONDS                    "[:80],
        line5,
        "C 6 DATA ENCODING: IBM FLOAT                            "[:80],
        f"C 7 min_inline, max_inline = ({il_min},{il_max})".ljust(80)[:80],
        f"C 8 min_xline, max_xline = ({xl_min},{xl_max})".ljust(80)[:80],
    ]
    # pad to 40 lines
    while len(lines) < 39:
        lines.append(("C{:>2d} ".format(len(lines)+1)).ljust(80)[:80])
    lines.append("C40 END TEXTUAL HEADER                                "[:80])
    return lines

# ================== MAIN WRITER ==================

def main():
    # Use Vp as the reference for crosslines + shape
    ref_prop = "Vp"
    xls, ref_map = discover_prop_files(PROP_DIRS[ref_prop], ref_prop)

    # Check other properties have matching crosslines (warn if not)
    prop_maps = {ref_prop: ref_map}
    for prop, pdir in PROP_DIRS.items():
        if prop == ref_prop:
            continue
        xls_p, mp = discover_prop_files(pdir, prop)
        prop_maps[prop] = mp
        if xls_p != xls:
            missing = sorted(set(xls) - set(xls_p))
            extra   = sorted(set(xls_p) - set(xls))
            if missing:
                print(f"[WARN] {prop}: missing crosslines (will error if encountered): {missing[:10]}{'...' if len(missing)>10 else ''}")
            if extra:
                print(f"[WARN] {prop}: extra crosslines not in Vp: {extra[:10]}{'...' if len(extra)>10 else ''}")

    # Determine (samples, inlines) from first Vp file
    first_path = ref_map[xls[0]]
    first_data = np.loadtxt(first_path, delimiter=",")
    if first_data.ndim != 2:
        raise RuntimeError(f"{first_path} must be 2D (time x inlines).")

    ns_raw, n_inlines = first_data.shape
    print(f"Reference file: {first_path.name} -> (samples={ns_raw}, inlines={n_inlines})")

    expected_inlines = 790 - 127 + 1
    if n_inlines != expected_inlines:
        print(f"[WARN] CSV columns = {n_inlines}, expected {expected_inlines} inlines (127â€“790).")

    nsamples   = target_rows
    n_xlines   = len(xls)
    num_traces = n_inlines * n_xlines

    # SEG-Y spec
    spec = segyio.spec()
    spec.ilines      = range(first_inline, first_inline + n_inlines)
    spec.xlines      = xls
    spec.samples     = range(nsamples)
    spec.sample_rate = sampling_interval
    spec.format      = 1  # IBM float

    il_min, il_max = first_inline, first_inline + n_inlines - 1
    xl_min, xl_max = xls[0], xls[-1]

    # Write one SEG-Y per property
    for prop, prop_dir in PROP_DIRS.items():
        out_sgy = OUT_FILES.get(prop, BASE / f"3D_{prop}.sgy")
        print(f"\n=== Writing {prop} volume from {prop_dir} -> {out_sgy} ===")

        mp = prop_maps[prop]

        with segyio.create(str(out_sgy), spec) as segyfile:
            # Text header
            hdr_lines = create_segy_text_header(num_traces, prop, il_min, il_max, xl_min, xl_max)
            segyfile.text[0] = segyio.tools.create_text_header(lines=hdr_lines)

            trace_index = 0

            for xl_no in xls:
                if xl_no not in mp:
                    raise RuntimeError(f"{prop}: missing file for crossline XL{xl_no} in {prop_dir}")

                csv_path = mp[xl_no]
                data = np.loadtxt(csv_path, delimiter=",")  # (time, inlines)

                if data.ndim != 2:
                    raise RuntimeError(f"{csv_path} must be 2D (time x inlines).")

                nt, nin = data.shape
                if nin != n_inlines:
                    raise RuntimeError(f"{csv_path}: expected {n_inlines} columns, got {nin}")

                # Pad zeros on TOP if shorter, or keep last nsamples if longer
                if nt < nsamples:
                    pad = np.zeros((nsamples - nt, nin), dtype=data.dtype)
                    data = np.vstack((pad, data))
                elif nt > nsamples:
                    data = data[-nsamples:, :]

                # Write traces for all inlines at this crossline
                for i_inline in range(n_inlines):
                    trace_data = data[:, i_inline].astype(np.float32)

                    inline_number    = first_inline + i_inline
                    crossline_number = xl_no

                    x_coord = origin_x + (crossline_number - first_crossline) * x_spacing
                    y_coord = origin_y + (inline_number   - first_inline)     * y_spacing

                    segyfile.trace[trace_index] = trace_data
                    segyfile.header[trace_index] = {
                        segyio.TraceField.INLINE_3D: inline_number,
                        segyio.TraceField.CROSSLINE_3D: crossline_number,
                        segyio.TraceField.SourceX: int(x_coord),
                        segyio.TraceField.SourceY: int(y_coord),
                        segyio.TraceField.TRACE_SAMPLE_INTERVAL: sampling_interval,
                        segyio.TraceField.TRACE_SEQUENCE_LINE: trace_index + 1,
                    }
                    trace_index += 1

            print(f"  -> Finished {prop}: wrote {trace_index} traces")

    print("\nAll requested SEG-Y volumes written successfully.")

if __name__ == "__main__":
    main()

